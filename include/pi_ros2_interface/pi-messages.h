
/*
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


/* THIS FILE HAS BEEN AUTOGENERATED BY generate.py, DO NOT MODIFY */

#ifndef PI_MESSAGES_H
#define PI_MESSAGES_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#ifdef PI_USE_PRINT_MSGS
#include <stdarg.h>
#endif
#include "pi-protocol.h"

// message payload parsing function
#if (PI_MODE & PI_RX)
pi_parse_msg_result_t piParseIntoMsg(pi_parse_states_t * p, const uint8_t byte);
#endif // #ifdef (PI_MODE & PI_RX)

//--------------------------
// ------ MESSAGES ---------
//--------------------------

// ------ IMU ------
#define PI_MSG_IMU_MODE PI_RXTX

#define PI_MSG_IMU_ID 1
#define PI_MSG_IMU_PAYLOAD_LEN 28

// msg definition
typedef struct __pi_IMU_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    float roll;
    float pitch;
    float yaw;
    float x;
    float y;
    float z;
} __attribute__((packed)) pi_IMU_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_IMU_MODE & PI_TX)
extern pi_IMU_t piMsgImuTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_IMU_MODE & PI_RX)
extern pi_IMU_t piMsgImuA;
extern pi_IMU_t piMsgImuB;
extern pi_IMU_t* piMsgImuRx;
extern pi_msg_rx_state_t piMsgImuRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgImu(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "Imu");
    if (piMsgImuRx) {
        printer("    piMsgImuRx.%s%1s %u\n", "time_us", ":", piMsgImuRx->time_us);
        printer("    piMsgImuRx.%s%4s %f\n", "roll", ":", (double)piMsgImuRx->roll);
        printer("    piMsgImuRx.%s%3s %f\n", "pitch", ":", (double)piMsgImuRx->pitch);
        printer("    piMsgImuRx.%s%5s %f\n", "yaw", ":", (double)piMsgImuRx->yaw);
        printer("    piMsgImuRx.%s%7s %f\n", "x", ":", (double)piMsgImuRx->x);
        printer("    piMsgImuRx.%s%7s %f\n", "y", ":", (double)piMsgImuRx->y);
        printer("    piMsgImuRx.%s%7s %f\n", "z", ":", (double)piMsgImuRx->z);
    } else {
        printer("    piMsgImuRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_IMU_MODE & PI_MSG_RX)


// ------ FAKE_GPS ------
#define PI_MSG_FAKE_GPS_MODE PI_RXTX

#define PI_MSG_FAKE_GPS_ID 2
#define PI_MSG_FAKE_GPS_PAYLOAD_LEN 23

// msg definition
typedef struct __pi_FAKE_GPS_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    int32_t lat;
    int32_t lon;
    int32_t altCm;
    uint16_t hdop;
    uint16_t groundSpeed;
    uint16_t groundCourse;
    uint8_t numSat;
} __attribute__((packed)) pi_FAKE_GPS_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_FAKE_GPS_MODE & PI_TX)
extern pi_FAKE_GPS_t piMsgFakeGpsTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_FAKE_GPS_MODE & PI_RX)
extern pi_FAKE_GPS_t piMsgFakeGpsA;
extern pi_FAKE_GPS_t piMsgFakeGpsB;
extern pi_FAKE_GPS_t* piMsgFakeGpsRx;
extern pi_msg_rx_state_t piMsgFakeGpsRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgFakeGps(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "FakeGps");
    if (piMsgFakeGpsRx) {
        printer("    piMsgFakeGpsRx.%s%6s %u\n", "time_us", ":", piMsgFakeGpsRx->time_us);
        printer("    piMsgFakeGpsRx.%s%10s %d\n", "lat", ":", piMsgFakeGpsRx->lat);
        printer("    piMsgFakeGpsRx.%s%10s %d\n", "lon", ":", piMsgFakeGpsRx->lon);
        printer("    piMsgFakeGpsRx.%s%8s %d\n", "altCm", ":", piMsgFakeGpsRx->altCm);
        printer("    piMsgFakeGpsRx.%s%9s %u\n", "hdop", ":", piMsgFakeGpsRx->hdop);
        printer("    piMsgFakeGpsRx.%s%2s %u\n", "groundSpeed", ":", piMsgFakeGpsRx->groundSpeed);
        printer("    piMsgFakeGpsRx.%s%1s %u\n", "groundCourse", ":", piMsgFakeGpsRx->groundCourse);
        printer("    piMsgFakeGpsRx.%s%7s %u\n", "numSat", ":", piMsgFakeGpsRx->numSat);
    } else {
        printer("    piMsgFakeGpsRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_FAKE_GPS_MODE & PI_MSG_RX)


// ------ EXTERNAL_POSE ------
#define PI_MSG_EXTERNAL_POSE_MODE PI_RXTX

#define PI_MSG_EXTERNAL_POSE_ID 3
#define PI_MSG_EXTERNAL_POSE_PAYLOAD_LEN 44

// msg definition
typedef struct __pi_EXTERNAL_POSE_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    float ned_x;
    float ned_y;
    float ned_z;
    float ned_xd;
    float ned_yd;
    float ned_zd;
    float body_qi;
    float body_qx;
    float body_qy;
    float body_qz;
} __attribute__((packed)) pi_EXTERNAL_POSE_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_EXTERNAL_POSE_MODE & PI_TX)
extern pi_EXTERNAL_POSE_t piMsgExternalPoseTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_EXTERNAL_POSE_MODE & PI_RX)
extern pi_EXTERNAL_POSE_t piMsgExternalPoseA;
extern pi_EXTERNAL_POSE_t piMsgExternalPoseB;
extern pi_EXTERNAL_POSE_t* piMsgExternalPoseRx;
extern pi_msg_rx_state_t piMsgExternalPoseRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgExternalPose(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "ExternalPose");
    if (piMsgExternalPoseRx) {
        printer("    piMsgExternalPoseRx.%s%1s %u\n", "time_us", ":", piMsgExternalPoseRx->time_us);
        printer("    piMsgExternalPoseRx.%s%3s %f\n", "ned_x", ":", (double)piMsgExternalPoseRx->ned_x);
        printer("    piMsgExternalPoseRx.%s%3s %f\n", "ned_y", ":", (double)piMsgExternalPoseRx->ned_y);
        printer("    piMsgExternalPoseRx.%s%3s %f\n", "ned_z", ":", (double)piMsgExternalPoseRx->ned_z);
        printer("    piMsgExternalPoseRx.%s%2s %f\n", "ned_xd", ":", (double)piMsgExternalPoseRx->ned_xd);
        printer("    piMsgExternalPoseRx.%s%2s %f\n", "ned_yd", ":", (double)piMsgExternalPoseRx->ned_yd);
        printer("    piMsgExternalPoseRx.%s%2s %f\n", "ned_zd", ":", (double)piMsgExternalPoseRx->ned_zd);
        printer("    piMsgExternalPoseRx.%s%1s %f\n", "body_qi", ":", (double)piMsgExternalPoseRx->body_qi);
        printer("    piMsgExternalPoseRx.%s%1s %f\n", "body_qx", ":", (double)piMsgExternalPoseRx->body_qx);
        printer("    piMsgExternalPoseRx.%s%1s %f\n", "body_qy", ":", (double)piMsgExternalPoseRx->body_qy);
        printer("    piMsgExternalPoseRx.%s%1s %f\n", "body_qz", ":", (double)piMsgExternalPoseRx->body_qz);
    } else {
        printer("    piMsgExternalPoseRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_EXTERNAL_POSE_MODE & PI_MSG_RX)


// ------ POS_SETPOINT ------
#define PI_MSG_POS_SETPOINT_MODE PI_RXTX

#define PI_MSG_POS_SETPOINT_ID 4
#define PI_MSG_POS_SETPOINT_PAYLOAD_LEN 32

// msg definition
typedef struct __pi_POS_SETPOINT_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    float ned_x;
    float ned_y;
    float ned_z;
    float ned_xd;
    float ned_yd;
    float ned_zd;
    float yaw;
} __attribute__((packed)) pi_POS_SETPOINT_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_POS_SETPOINT_MODE & PI_TX)
extern pi_POS_SETPOINT_t piMsgPosSetpointTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_POS_SETPOINT_MODE & PI_RX)
extern pi_POS_SETPOINT_t piMsgPosSetpointA;
extern pi_POS_SETPOINT_t piMsgPosSetpointB;
extern pi_POS_SETPOINT_t* piMsgPosSetpointRx;
extern pi_msg_rx_state_t piMsgPosSetpointRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgPosSetpoint(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "PosSetpoint");
    if (piMsgPosSetpointRx) {
        printer("    piMsgPosSetpointRx.%s%1s %u\n", "time_us", ":", piMsgPosSetpointRx->time_us);
        printer("    piMsgPosSetpointRx.%s%3s %f\n", "ned_x", ":", (double)piMsgPosSetpointRx->ned_x);
        printer("    piMsgPosSetpointRx.%s%3s %f\n", "ned_y", ":", (double)piMsgPosSetpointRx->ned_y);
        printer("    piMsgPosSetpointRx.%s%3s %f\n", "ned_z", ":", (double)piMsgPosSetpointRx->ned_z);
        printer("    piMsgPosSetpointRx.%s%2s %f\n", "ned_xd", ":", (double)piMsgPosSetpointRx->ned_xd);
        printer("    piMsgPosSetpointRx.%s%2s %f\n", "ned_yd", ":", (double)piMsgPosSetpointRx->ned_yd);
        printer("    piMsgPosSetpointRx.%s%2s %f\n", "ned_zd", ":", (double)piMsgPosSetpointRx->ned_zd);
        printer("    piMsgPosSetpointRx.%s%5s %f\n", "yaw", ":", (double)piMsgPosSetpointRx->yaw);
    } else {
        printer("    piMsgPosSetpointRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_POS_SETPOINT_MODE & PI_MSG_RX)


// ------ HIL_IN ------
#define PI_MSG_HIL_IN_MODE PI_RXTX

#define PI_MSG_HIL_IN_ID 5
#define PI_MSG_HIL_IN_PAYLOAD_LEN 26

// msg definition
typedef struct __pi_HIL_IN_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    int16_t gyro_x;
    int16_t gyro_y;
    int16_t gyro_z;
    int16_t acc_x;
    int16_t acc_y;
    int16_t acc_z;
    int16_t baro;
    int16_t rpm_1;
    int16_t rpm_2;
    int16_t rpm_3;
    int16_t rpm_4;
} __attribute__((packed)) pi_HIL_IN_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_HIL_IN_MODE & PI_TX)
extern pi_HIL_IN_t piMsgHilInTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_HIL_IN_MODE & PI_RX)
extern pi_HIL_IN_t piMsgHilInA;
extern pi_HIL_IN_t piMsgHilInB;
extern pi_HIL_IN_t* piMsgHilInRx;
extern pi_msg_rx_state_t piMsgHilInRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgHilIn(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "HilIn");
    if (piMsgHilInRx) {
        printer("    piMsgHilInRx.%s%1s %u\n", "time_us", ":", piMsgHilInRx->time_us);
        printer("    piMsgHilInRx.%s%2s %d\n", "gyro_x", ":", piMsgHilInRx->gyro_x);
        printer("    piMsgHilInRx.%s%2s %d\n", "gyro_y", ":", piMsgHilInRx->gyro_y);
        printer("    piMsgHilInRx.%s%2s %d\n", "gyro_z", ":", piMsgHilInRx->gyro_z);
        printer("    piMsgHilInRx.%s%3s %d\n", "acc_x", ":", piMsgHilInRx->acc_x);
        printer("    piMsgHilInRx.%s%3s %d\n", "acc_y", ":", piMsgHilInRx->acc_y);
        printer("    piMsgHilInRx.%s%3s %d\n", "acc_z", ":", piMsgHilInRx->acc_z);
        printer("    piMsgHilInRx.%s%4s %d\n", "baro", ":", piMsgHilInRx->baro);
        printer("    piMsgHilInRx.%s%3s %d\n", "rpm_1", ":", piMsgHilInRx->rpm_1);
        printer("    piMsgHilInRx.%s%3s %d\n", "rpm_2", ":", piMsgHilInRx->rpm_2);
        printer("    piMsgHilInRx.%s%3s %d\n", "rpm_3", ":", piMsgHilInRx->rpm_3);
        printer("    piMsgHilInRx.%s%3s %d\n", "rpm_4", ":", piMsgHilInRx->rpm_4);
    } else {
        printer("    piMsgHilInRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_HIL_IN_MODE & PI_MSG_RX)


// ------ HIL_OUT ------
#define PI_MSG_HIL_OUT_MODE PI_RXTX

#define PI_MSG_HIL_OUT_ID 6
#define PI_MSG_HIL_OUT_PAYLOAD_LEN 12

// msg definition
typedef struct __pi_HIL_OUT_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    int16_t set_1;
    int16_t set_2;
    int16_t set_3;
    int16_t set_4;
} __attribute__((packed)) pi_HIL_OUT_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_HIL_OUT_MODE & PI_TX)
extern pi_HIL_OUT_t piMsgHilOutTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_HIL_OUT_MODE & PI_RX)
extern pi_HIL_OUT_t piMsgHilOutA;
extern pi_HIL_OUT_t piMsgHilOutB;
extern pi_HIL_OUT_t* piMsgHilOutRx;
extern pi_msg_rx_state_t piMsgHilOutRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgHilOut(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "HilOut");
    if (piMsgHilOutRx) {
        printer("    piMsgHilOutRx.%s%1s %u\n", "time_us", ":", piMsgHilOutRx->time_us);
        printer("    piMsgHilOutRx.%s%3s %d\n", "set_1", ":", piMsgHilOutRx->set_1);
        printer("    piMsgHilOutRx.%s%3s %d\n", "set_2", ":", piMsgHilOutRx->set_2);
        printer("    piMsgHilOutRx.%s%3s %d\n", "set_3", ":", piMsgHilOutRx->set_3);
        printer("    piMsgHilOutRx.%s%3s %d\n", "set_4", ":", piMsgHilOutRx->set_4);
    } else {
        printer("    piMsgHilOutRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_HIL_OUT_MODE & PI_MSG_RX)


// ------ VIO_POSE ------
#define PI_MSG_VIO_POSE_MODE PI_RXTX

#define PI_MSG_VIO_POSE_ID 7
#define PI_MSG_VIO_POSE_PAYLOAD_LEN 56

// msg definition
typedef struct __pi_VIO_POSE_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    float x;
    float y;
    float z;
    float vx;
    float vy;
    float vz;
    float p;
    float q;
    float r;
    float qw;
    float qx;
    float qy;
    float qz;
} __attribute__((packed)) pi_VIO_POSE_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_VIO_POSE_MODE & PI_TX)
extern pi_VIO_POSE_t piMsgVioPoseTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_VIO_POSE_MODE & PI_RX)
extern pi_VIO_POSE_t piMsgVioPoseA;
extern pi_VIO_POSE_t piMsgVioPoseB;
extern pi_VIO_POSE_t* piMsgVioPoseRx;
extern pi_msg_rx_state_t piMsgVioPoseRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgVioPose(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "VioPose");
    if (piMsgVioPoseRx) {
        printer("    piMsgVioPoseRx.%s%1s %u\n", "time_us", ":", piMsgVioPoseRx->time_us);
        printer("    piMsgVioPoseRx.%s%7s %f\n", "x", ":", (double)piMsgVioPoseRx->x);
        printer("    piMsgVioPoseRx.%s%7s %f\n", "y", ":", (double)piMsgVioPoseRx->y);
        printer("    piMsgVioPoseRx.%s%7s %f\n", "z", ":", (double)piMsgVioPoseRx->z);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "vx", ":", (double)piMsgVioPoseRx->vx);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "vy", ":", (double)piMsgVioPoseRx->vy);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "vz", ":", (double)piMsgVioPoseRx->vz);
        printer("    piMsgVioPoseRx.%s%7s %f\n", "p", ":", (double)piMsgVioPoseRx->p);
        printer("    piMsgVioPoseRx.%s%7s %f\n", "q", ":", (double)piMsgVioPoseRx->q);
        printer("    piMsgVioPoseRx.%s%7s %f\n", "r", ":", (double)piMsgVioPoseRx->r);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "qw", ":", (double)piMsgVioPoseRx->qw);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "qx", ":", (double)piMsgVioPoseRx->qx);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "qy", ":", (double)piMsgVioPoseRx->qy);
        printer("    piMsgVioPoseRx.%s%6s %f\n", "qz", ":", (double)piMsgVioPoseRx->qz);
    } else {
        printer("    piMsgVioPoseRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_VIO_POSE_MODE & PI_MSG_RX)


// ------ KEYBOARD ------
#define PI_MSG_KEYBOARD_MODE PI_RXTX

#define PI_MSG_KEYBOARD_ID 8
#define PI_MSG_KEYBOARD_PAYLOAD_LEN 5

// msg definition
typedef struct __pi_KEYBOARD_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    uint8_t key;
} __attribute__((packed)) pi_KEYBOARD_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_KEYBOARD_MODE & PI_TX)
extern pi_KEYBOARD_t piMsgKeyboardTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_KEYBOARD_MODE & PI_RX)
extern pi_KEYBOARD_t piMsgKeyboardA;
extern pi_KEYBOARD_t piMsgKeyboardB;
extern pi_KEYBOARD_t* piMsgKeyboardRx;
extern pi_msg_rx_state_t piMsgKeyboardRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgKeyboard(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "Keyboard");
    if (piMsgKeyboardRx) {
        printer("    piMsgKeyboardRx.%s%1s %u\n", "time_us", ":", piMsgKeyboardRx->time_us);
        printer("    piMsgKeyboardRx.%s%5s %u\n", "key", ":", piMsgKeyboardRx->key);
    } else {
        printer("    piMsgKeyboardRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_KEYBOARD_MODE & PI_MSG_RX)


// ------ EKF_INPUTS ------
#define PI_MSG_EKF_INPUTS_MODE PI_RXTX

#define PI_MSG_EKF_INPUTS_ID 9
#define PI_MSG_EKF_INPUTS_PAYLOAD_LEN 24

// msg definition
typedef struct __pi_EKF_INPUTS_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    int16_t x;
    int16_t y;
    int16_t z;
    int16_t p;
    int16_t q;
    int16_t r;
    uint16_t omega1;
    uint16_t omega2;
    uint16_t omega3;
    uint16_t omega4;
} __attribute__((packed)) pi_EKF_INPUTS_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_EKF_INPUTS_MODE & PI_TX)
extern pi_EKF_INPUTS_t piMsgEkfInputsTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_EKF_INPUTS_MODE & PI_RX)
extern pi_EKF_INPUTS_t piMsgEkfInputsA;
extern pi_EKF_INPUTS_t piMsgEkfInputsB;
extern pi_EKF_INPUTS_t* piMsgEkfInputsRx;
extern pi_msg_rx_state_t piMsgEkfInputsRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgEkfInputs(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "EkfInputs");
    if (piMsgEkfInputsRx) {
        printer("    piMsgEkfInputsRx.%s%1s %u\n", "time_us", ":", piMsgEkfInputsRx->time_us);
        printer("    piMsgEkfInputsRx.%s%7s %d\n", "x", ":", piMsgEkfInputsRx->x);
        printer("    piMsgEkfInputsRx.%s%7s %d\n", "y", ":", piMsgEkfInputsRx->y);
        printer("    piMsgEkfInputsRx.%s%7s %d\n", "z", ":", piMsgEkfInputsRx->z);
        printer("    piMsgEkfInputsRx.%s%7s %d\n", "p", ":", piMsgEkfInputsRx->p);
        printer("    piMsgEkfInputsRx.%s%7s %d\n", "q", ":", piMsgEkfInputsRx->q);
        printer("    piMsgEkfInputsRx.%s%7s %d\n", "r", ":", piMsgEkfInputsRx->r);
        printer("    piMsgEkfInputsRx.%s%2s %u\n", "omega1", ":", piMsgEkfInputsRx->omega1);
        printer("    piMsgEkfInputsRx.%s%2s %u\n", "omega2", ":", piMsgEkfInputsRx->omega2);
        printer("    piMsgEkfInputsRx.%s%2s %u\n", "omega3", ":", piMsgEkfInputsRx->omega3);
        printer("    piMsgEkfInputsRx.%s%2s %u\n", "omega4", ":", piMsgEkfInputsRx->omega4);
    } else {
        printer("    piMsgEkfInputsRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_EKF_INPUTS_MODE & PI_MSG_RX)


// ------ OFFBOARD_POSE ------
#define PI_MSG_OFFBOARD_POSE_MODE PI_RXTX

#define PI_MSG_OFFBOARD_POSE_ID 10
#define PI_MSG_OFFBOARD_POSE_PAYLOAD_LEN 24

// msg definition
typedef struct __pi_OFFBOARD_POSE_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    float x;
    float y;
    float z;
    int16_t qw;
    int16_t qx;
    int16_t qy;
    int16_t qz;
} __attribute__((packed)) pi_OFFBOARD_POSE_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_OFFBOARD_POSE_MODE & PI_TX)
extern pi_OFFBOARD_POSE_t piMsgOffboardPoseTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_OFFBOARD_POSE_MODE & PI_RX)
extern pi_OFFBOARD_POSE_t piMsgOffboardPoseA;
extern pi_OFFBOARD_POSE_t piMsgOffboardPoseB;
extern pi_OFFBOARD_POSE_t* piMsgOffboardPoseRx;
extern pi_msg_rx_state_t piMsgOffboardPoseRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgOffboardPose(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "OffboardPose");
    if (piMsgOffboardPoseRx) {
        printer("    piMsgOffboardPoseRx.%s%1s %u\n", "time_us", ":", piMsgOffboardPoseRx->time_us);
        printer("    piMsgOffboardPoseRx.%s%7s %f\n", "x", ":", (double)piMsgOffboardPoseRx->x);
        printer("    piMsgOffboardPoseRx.%s%7s %f\n", "y", ":", (double)piMsgOffboardPoseRx->y);
        printer("    piMsgOffboardPoseRx.%s%7s %f\n", "z", ":", (double)piMsgOffboardPoseRx->z);
        printer("    piMsgOffboardPoseRx.%s%6s %d\n", "qw", ":", piMsgOffboardPoseRx->qw);
        printer("    piMsgOffboardPoseRx.%s%6s %d\n", "qx", ":", piMsgOffboardPoseRx->qx);
        printer("    piMsgOffboardPoseRx.%s%6s %d\n", "qy", ":", piMsgOffboardPoseRx->qy);
        printer("    piMsgOffboardPoseRx.%s%6s %d\n", "qz", ":", piMsgOffboardPoseRx->qz);
    } else {
        printer("    piMsgOffboardPoseRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_OFFBOARD_POSE_MODE & PI_MSG_RX)


// ------ OFFBOARD_POSE_COV ------
#define PI_MSG_OFFBOARD_POSE_COV_MODE PI_RXTX

#define PI_MSG_OFFBOARD_POSE_COV_ID 11
#define PI_MSG_OFFBOARD_POSE_COV_PAYLOAD_LEN 60

// msg definition
typedef struct __pi_OFFBOARD_POSE_COV_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    int16_t c00;
    int16_t c01;
    int16_t c11;
    int16_t c02;
    int16_t c12;
    int16_t c22;
    int16_t c03;
    int16_t c13;
    int16_t c23;
    int16_t c33;
    int16_t c04;
    int16_t c14;
    int16_t c24;
    int16_t c34;
    int16_t c44;
    int16_t c05;
    int16_t c15;
    int16_t c25;
    int16_t c35;
    int16_t c45;
    int16_t c55;
    int16_t c06;
    int16_t c16;
    int16_t c26;
    int16_t c36;
    int16_t c46;
    int16_t c56;
    int16_t c66;
} __attribute__((packed)) pi_OFFBOARD_POSE_COV_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_OFFBOARD_POSE_COV_MODE & PI_TX)
extern pi_OFFBOARD_POSE_COV_t piMsgOffboardPoseCovTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_OFFBOARD_POSE_COV_MODE & PI_RX)
extern pi_OFFBOARD_POSE_COV_t piMsgOffboardPoseCovA;
extern pi_OFFBOARD_POSE_COV_t piMsgOffboardPoseCovB;
extern pi_OFFBOARD_POSE_COV_t* piMsgOffboardPoseCovRx;
extern pi_msg_rx_state_t piMsgOffboardPoseCovRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgOffboardPoseCov(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "OffboardPoseCov");
    if (piMsgOffboardPoseCovRx) {
        printer("    piMsgOffboardPoseCovRx.%s%1s %u\n", "time_us", ":", piMsgOffboardPoseCovRx->time_us);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c00", ":", piMsgOffboardPoseCovRx->c00);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c01", ":", piMsgOffboardPoseCovRx->c01);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c11", ":", piMsgOffboardPoseCovRx->c11);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c02", ":", piMsgOffboardPoseCovRx->c02);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c12", ":", piMsgOffboardPoseCovRx->c12);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c22", ":", piMsgOffboardPoseCovRx->c22);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c03", ":", piMsgOffboardPoseCovRx->c03);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c13", ":", piMsgOffboardPoseCovRx->c13);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c23", ":", piMsgOffboardPoseCovRx->c23);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c33", ":", piMsgOffboardPoseCovRx->c33);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c04", ":", piMsgOffboardPoseCovRx->c04);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c14", ":", piMsgOffboardPoseCovRx->c14);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c24", ":", piMsgOffboardPoseCovRx->c24);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c34", ":", piMsgOffboardPoseCovRx->c34);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c44", ":", piMsgOffboardPoseCovRx->c44);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c05", ":", piMsgOffboardPoseCovRx->c05);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c15", ":", piMsgOffboardPoseCovRx->c15);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c25", ":", piMsgOffboardPoseCovRx->c25);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c35", ":", piMsgOffboardPoseCovRx->c35);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c45", ":", piMsgOffboardPoseCovRx->c45);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c55", ":", piMsgOffboardPoseCovRx->c55);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c06", ":", piMsgOffboardPoseCovRx->c06);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c16", ":", piMsgOffboardPoseCovRx->c16);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c26", ":", piMsgOffboardPoseCovRx->c26);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c36", ":", piMsgOffboardPoseCovRx->c36);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c46", ":", piMsgOffboardPoseCovRx->c46);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c56", ":", piMsgOffboardPoseCovRx->c56);
        printer("    piMsgOffboardPoseCovRx.%s%5s %d\n", "c66", ":", piMsgOffboardPoseCovRx->c66);
    } else {
        printer("    piMsgOffboardPoseCovRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_OFFBOARD_POSE_COV_MODE & PI_MSG_RX)


// ------ DUMMY_MESSAGE ------
#define PI_MSG_DUMMY_MESSAGE_MODE PI_RXTX

#define PI_MSG_DUMMY_MESSAGE_ID 12
#define PI_MSG_DUMMY_MESSAGE_PAYLOAD_LEN 20

// msg definition
typedef struct __pi_DUMMY_MESSAGE_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    double roll;
    double roll1;
} __attribute__((packed)) pi_DUMMY_MESSAGE_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_DUMMY_MESSAGE_MODE & PI_TX)
extern pi_DUMMY_MESSAGE_t piMsgDummyMessageTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_DUMMY_MESSAGE_MODE & PI_RX)
extern pi_DUMMY_MESSAGE_t piMsgDummyMessageA;
extern pi_DUMMY_MESSAGE_t piMsgDummyMessageB;
extern pi_DUMMY_MESSAGE_t* piMsgDummyMessageRx;
extern pi_msg_rx_state_t piMsgDummyMessageRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgDummyMessage(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "DummyMessage");
    if (piMsgDummyMessageRx) {
        printer("    piMsgDummyMessageRx.%s%1s %u\n", "time_us", ":", piMsgDummyMessageRx->time_us);
        printer("    piMsgDummyMessageRx.%s%4s %f\n", "roll", ":", piMsgDummyMessageRx->roll);
        printer("    piMsgDummyMessageRx.%s%3s %f\n", "roll1", ":", piMsgDummyMessageRx->roll1);
    } else {
        printer("    piMsgDummyMessageRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_DUMMY_MESSAGE_MODE & PI_MSG_RX)


// ------ EAGLE_STATES ------
#define PI_MSG_EAGLE_STATES_MODE PI_RXTX

#define PI_MSG_EAGLE_STATES_ID 13
#define PI_MSG_EAGLE_STATES_PAYLOAD_LEN 88

// msg definition
typedef struct __pi_EAGLE_STATES_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    float ax;
    float ay;
    float az;
    float ax_filtered;
    float ay_filtered;
    float az_filtered;
    float wx;
    float wy;
    float wz;
    float wx_dot_filtered;
    float wy_dot_filtered;
    float wz_dot_filtered;
    float qw;
    float qx;
    float qy;
    float qz;
    float motor_0;
    float motor_1;
    float motor_2;
    float motor_3;
    float aux;
} __attribute__((packed)) pi_EAGLE_STATES_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_EAGLE_STATES_MODE & PI_TX)
extern pi_EAGLE_STATES_t piMsgEagleStatesTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_EAGLE_STATES_MODE & PI_RX)
extern pi_EAGLE_STATES_t piMsgEagleStatesA;
extern pi_EAGLE_STATES_t piMsgEagleStatesB;
extern pi_EAGLE_STATES_t* piMsgEagleStatesRx;
extern pi_msg_rx_state_t piMsgEagleStatesRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgEagleStates(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "EagleStates");
    if (piMsgEagleStatesRx) {
        printer("    piMsgEagleStatesRx.%s%9s %u\n", "time_us", ":", piMsgEagleStatesRx->time_us);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "ax", ":", (double)piMsgEagleStatesRx->ax);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "ay", ":", (double)piMsgEagleStatesRx->ay);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "az", ":", (double)piMsgEagleStatesRx->az);
        printer("    piMsgEagleStatesRx.%s%5s %f\n", "ax_filtered", ":", (double)piMsgEagleStatesRx->ax_filtered);
        printer("    piMsgEagleStatesRx.%s%5s %f\n", "ay_filtered", ":", (double)piMsgEagleStatesRx->ay_filtered);
        printer("    piMsgEagleStatesRx.%s%5s %f\n", "az_filtered", ":", (double)piMsgEagleStatesRx->az_filtered);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "wx", ":", (double)piMsgEagleStatesRx->wx);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "wy", ":", (double)piMsgEagleStatesRx->wy);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "wz", ":", (double)piMsgEagleStatesRx->wz);
        printer("    piMsgEagleStatesRx.%s%1s %f\n", "wx_dot_filtered", ":", (double)piMsgEagleStatesRx->wx_dot_filtered);
        printer("    piMsgEagleStatesRx.%s%1s %f\n", "wy_dot_filtered", ":", (double)piMsgEagleStatesRx->wy_dot_filtered);
        printer("    piMsgEagleStatesRx.%s%1s %f\n", "wz_dot_filtered", ":", (double)piMsgEagleStatesRx->wz_dot_filtered);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "qw", ":", (double)piMsgEagleStatesRx->qw);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "qx", ":", (double)piMsgEagleStatesRx->qx);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "qy", ":", (double)piMsgEagleStatesRx->qy);
        printer("    piMsgEagleStatesRx.%s%14s %f\n", "qz", ":", (double)piMsgEagleStatesRx->qz);
        printer("    piMsgEagleStatesRx.%s%9s %f\n", "motor_0", ":", (double)piMsgEagleStatesRx->motor_0);
        printer("    piMsgEagleStatesRx.%s%9s %f\n", "motor_1", ":", (double)piMsgEagleStatesRx->motor_1);
        printer("    piMsgEagleStatesRx.%s%9s %f\n", "motor_2", ":", (double)piMsgEagleStatesRx->motor_2);
        printer("    piMsgEagleStatesRx.%s%9s %f\n", "motor_3", ":", (double)piMsgEagleStatesRx->motor_3);
        printer("    piMsgEagleStatesRx.%s%13s %f\n", "aux", ":", (double)piMsgEagleStatesRx->aux);
    } else {
        printer("    piMsgEagleStatesRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_EAGLE_STATES_MODE & PI_MSG_RX)


// ------ EAGLE_OFFBOARD ------
#define PI_MSG_EAGLE_OFFBOARD_MODE PI_RXTX

#define PI_MSG_EAGLE_OFFBOARD_ID 14
#define PI_MSG_EAGLE_OFFBOARD_PAYLOAD_LEN 38

// msg definition
typedef struct __pi_EAGLE_OFFBOARD_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    uint8_t active_attitude;
    uint8_t active_acro;
    float throttle_d;
    float qw_d;
    float qx_d;
    float qy_d;
    float qz_d;
    float wx_d;
    float wy_d;
    float wz_d;
} __attribute__((packed)) pi_EAGLE_OFFBOARD_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_EAGLE_OFFBOARD_MODE & PI_TX)
extern pi_EAGLE_OFFBOARD_t piMsgEagleOffboardTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_EAGLE_OFFBOARD_MODE & PI_RX)
extern pi_EAGLE_OFFBOARD_t piMsgEagleOffboardA;
extern pi_EAGLE_OFFBOARD_t piMsgEagleOffboardB;
extern pi_EAGLE_OFFBOARD_t* piMsgEagleOffboardRx;
extern pi_msg_rx_state_t piMsgEagleOffboardRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgEagleOffboard(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "EagleOffboard");
    if (piMsgEagleOffboardRx) {
        printer("    piMsgEagleOffboardRx.%s%9s %u\n", "time_us", ":", piMsgEagleOffboardRx->time_us);
        printer("    piMsgEagleOffboardRx.%s%1s %u\n", "active_attitude", ":", piMsgEagleOffboardRx->active_attitude);
        printer("    piMsgEagleOffboardRx.%s%5s %u\n", "active_acro", ":", piMsgEagleOffboardRx->active_acro);
        printer("    piMsgEagleOffboardRx.%s%6s %f\n", "throttle_d", ":", (double)piMsgEagleOffboardRx->throttle_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "qw_d", ":", (double)piMsgEagleOffboardRx->qw_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "qx_d", ":", (double)piMsgEagleOffboardRx->qx_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "qy_d", ":", (double)piMsgEagleOffboardRx->qy_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "qz_d", ":", (double)piMsgEagleOffboardRx->qz_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "wx_d", ":", (double)piMsgEagleOffboardRx->wx_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "wy_d", ":", (double)piMsgEagleOffboardRx->wy_d);
        printer("    piMsgEagleOffboardRx.%s%12s %f\n", "wz_d", ":", (double)piMsgEagleOffboardRx->wz_d);
    } else {
        printer("    piMsgEagleOffboardRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_EAGLE_OFFBOARD_MODE & PI_MSG_RX)


// ------ EAGLE_ONBOARD_CONTROL ------
#define PI_MSG_EAGLE_ONBOARD_CONTROL_MODE PI_RXTX

#define PI_MSG_EAGLE_ONBOARD_CONTROL_ID 15
#define PI_MSG_EAGLE_ONBOARD_CONTROL_PAYLOAD_LEN 39

// msg definition
typedef struct __pi_EAGLE_ONBOARD_CONTROL_t
{
    uint8_t id;
    uint8_t len;
    // start of payload
    uint32_t time_us;
    uint8_t active_offboard;
    uint8_t active_attitude;
    uint8_t active_acro;
    float throttle_d;
    float qw_d;
    float qx_d;
    float qy_d;
    float qz_d;
    float wx_d;
    float wy_d;
    float wz_d;
} __attribute__((packed)) pi_EAGLE_ONBOARD_CONTROL_t;

// todo: we can save on memory, if we use a union as the tx-buffer and not
// separate structs, if they are only used one-at-a-time
#if (PI_MODE & PI_TX) && (PI_MSG_EAGLE_ONBOARD_CONTROL_MODE & PI_TX)
extern pi_EAGLE_ONBOARD_CONTROL_t piMsgEagleOnboardControlTx;
#endif

#if (PI_MODE & PI_RX) && (PI_MSG_EAGLE_ONBOARD_CONTROL_MODE & PI_RX)
extern pi_EAGLE_ONBOARD_CONTROL_t piMsgEagleOnboardControlA;
extern pi_EAGLE_ONBOARD_CONTROL_t piMsgEagleOnboardControlB;
extern pi_EAGLE_ONBOARD_CONTROL_t* piMsgEagleOnboardControlRx;
extern pi_msg_rx_state_t piMsgEagleOnboardControlRxState;

//print function
#ifdef PI_USE_PRINT_MSGS
__attribute__((unused)) static inline void piPrintMsgEagleOnboardControl(int (* printer)(const char* fmt, ...)) {
    printer("%s\n", "EagleOnboardControl");
    if (piMsgEagleOnboardControlRx) {
        printer("    piMsgEagleOnboardControlRx.%s%9s %u\n", "time_us", ":", piMsgEagleOnboardControlRx->time_us);
        printer("    piMsgEagleOnboardControlRx.%s%1s %u\n", "active_offboard", ":", piMsgEagleOnboardControlRx->active_offboard);
        printer("    piMsgEagleOnboardControlRx.%s%1s %u\n", "active_attitude", ":", piMsgEagleOnboardControlRx->active_attitude);
        printer("    piMsgEagleOnboardControlRx.%s%5s %u\n", "active_acro", ":", piMsgEagleOnboardControlRx->active_acro);
        printer("    piMsgEagleOnboardControlRx.%s%6s %f\n", "throttle_d", ":", (double)piMsgEagleOnboardControlRx->throttle_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "qw_d", ":", (double)piMsgEagleOnboardControlRx->qw_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "qx_d", ":", (double)piMsgEagleOnboardControlRx->qx_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "qy_d", ":", (double)piMsgEagleOnboardControlRx->qy_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "qz_d", ":", (double)piMsgEagleOnboardControlRx->qz_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "wx_d", ":", (double)piMsgEagleOnboardControlRx->wx_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "wy_d", ":", (double)piMsgEagleOnboardControlRx->wy_d);
        printer("    piMsgEagleOnboardControlRx.%s%12s %f\n", "wz_d", ":", (double)piMsgEagleOnboardControlRx->wz_d);
    } else {
        printer("    piMsgEagleOnboardControlRx is NULL. Message likely not received yet.\n");
    }
    printer("-----------\n");
}

#endif // #ifdef PI_USE_PRINT_MSGS

#endif // #if (PI_MODE & PI_RX) && (PI_MSG_EAGLE_ONBOARD_CONTROL_MODE & PI_MSG_RX)


 
#ifdef __cplusplus
}
#endif

#endif // #ifndef PI_MESSAGES_H
